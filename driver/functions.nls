;; FUNCTIONS FOR THE DRIVER TURTLES

to driver-act
	ifelse state = 2 [
		action-2-driver
	][
		ifelse state = 0 [
			action-0-driver
		][
			if state = 1 [
				action-1-driver
			]
		]
	]
end

to action-2-driver 
	let xcord xcor
	let ycord ycor
	let initial_vertex last_vertex ; the vertex where it was last stanted
	let current_vertex sort vertices with [xcor = xcord and ycor = ycord]
	if not empty? current_vertex [set current_vertex item 0 current_vertex]
	if not empty? path [
		if current_vertex = item 0 path [
			;remove node from path
			set path remove-item 0 path
			set last_vertex current_vertex
		]
	]
	if empty? path[
		; get current node
		if current_vertex = nobody [
			set current_vertex min-one-of (vertices) [distance self]
		]

		;get get one of the neighboors randomly
		;asign it to path
		let goal one-of vertices with [self != initial_vertex]
		if goal != last_vertex [
			dijkstra last_vertex goal
		]
	]
	;move to path
	;go-towards self item 0 path
	move-in-path
end

to action-0-driver
	; if position is equal of customer: ask costumer to get in and change state
	ifelse xcor = [xcor] of customer and ycor = [ycor] of customer [
		ask customer [
			get-in
		]

    going-to-destination-change
		dijkstra last_vertex [destination] of customer
    
    price-drive path
    
	][
		; else move to customer
		; go-towards self customer
		move-in-path
	]
end

to price-drive [path-d]
  ;; This "function" evaluates path's cost of customer destination
  let initial-xcor 0
  let initial-ycor 0
  let final-xcor 0
  let final-ycor 0
  let magnitude 0
  let total-cost 0
  let f 0
  let numbers-path 0
  let range-path []
  let price-taxi 0
  let price-uber 0
  
  set numbers-path length path-d - 1
  set range-path n-values numbers-path [ i -> i ]
    
  foreach range-path [ [i] ->
    set f i + 1
    set initial-xcor [xcor] of item i path-d
    set initial-ycor [ycor] of item i path-d
    set final-xcor [xcor] of item f path-d
    set final-ycor [ycor] of item f path-d
    set magnitude (sqrt(((final-xcor - initial-xcor) * (final-xcor - initial-xcor)) + ((final-ycor - initial-ycor) * (final-ycor - initial-ycor)))) / 0.86
    set total-cost total-cost + magnitude
 ]
  set price-taxi ((total-cost * 1000) * 0.8198) + 4020.7
  set price-uber (total-cost * 708.48) + 3533.3
  
  print price-taxi
  print price-uber
  print total-cost

end


to action-1-driver
	ifelse xcor = [xcor] of [destination] of customer and ycor = [ycor] of [destination] of customer [
		ask customer [
			get-out
		]
		change-to-free
	][
		; else move to customer
		;go-towards self [destination] of customer
		move-in-path
	]
end

to change-to-free
	set_state_driver 2
	set shape "circle 2"
	set customer nobody
	set path []
end

to going-to-customer-change
	set_state_driver 0
	set shape "circle"
end

to going-to-destination-change
	set_state_driver 1
	set shape "target"
end

; ---------- this function takes care of executing the correct assignment function for drivers ------------
to assignment_policy_fn_drivers [current_person]
	if not empty? sort drivers with [state = 2] [

		let type_of_driver? "taxi"
		let radius_driver_policy radius_driver_policy_taxi
		if uber? current_person [
			set type_of_driver? "uber"
			set radius_driver_policy radius_driver_policy_uber
		]

		; decide which policy to use for choosing the driver
		let drivers_set drivers with [distance current_person <= radius_driver_policy / 100 * (max list max-x max-y) AND state = 2 AND type-of-driver = type_of_driver?]

		let driverToBeAssigned nobody

		ifelse type_of_driver? = "uber" [

			ifelse choosing_driver_policy_code_uber = "closest" [
				set driverToBeAssigned min-one-of drivers_set [distance current_person]
			][
				ifelse choosing_driver_policy_code_uber = "fifo" [
					set driverToBeAssigned min-one-of drivers_set [last_status_change]
				][
					if choosing_driver_policy_code_uber = "randomly" [
						set driverToBeAssigned one-of drivers_set	
					]
				]
			]
			
		][

			if type_of_driver? = "taxi" [
				ifelse choosing_driver_policy_code_taxi = "closest" [
					set driverToBeAssigned min-one-of drivers_set [distance current_person]
				][
					ifelse choosing_driver_policy_code_taxi = "fifo" [
						set driverToBeAssigned min-one-of drivers_set [last_status_change]
					][
						if choosing_driver_policy_code_taxi = "randomly" [
							set driverToBeAssigned one-of drivers_set	
						]
					]
				]
			]

		]

		if driverToBeAssigned != nobody [
			set own-driver driverToBeAssigned ; perhaps use ask current_person [set own-dri...
			ask own-driver [
				going-to-customer-change
				ask current_person [
					set_state_person 2
				]
				set customer current_person 
				dijkstra last_vertex [current_vertice] of current_person

			]
		]
	]
end

to set_state_driver [value]
	set state value
	set last_status_change ticks
end
