;; FUNCTIONS FOR THE DRIVER TURTLES

to driver-act
	ifelse state = 2 [
		action-2-driver
	][
		ifelse state = 0 [
			action-0-driver
		][
			if state = 1 [
				action-1-driver
			]
		]
	]
end

to action-2-driver 
	let xcord xcor
	let ycord ycor
	let current_vertex sort vertices with [xcor = xcord and ycor = ycord]
	if not empty? current_vertex [set current_vertex item 0 current_vertex]
	if not empty? path [
		if current_vertex = item 0 path [
			;remove node from path
			set path remove-item 0 path
		]
	]
	if empty? path[
		;get current node
		if current_vertex = nobody [
			set current_vertex min-one-of (vertices) [distance self]
		]

		;get get one of the neighboors randomly
		;asign it to path
		let goal nobody
		ask current_vertex [
			set goal one-of link-neighbors
		]
		if goal != nobody [set path (list goal)]
	]
	;move to path
	go-towards self item 0 path
end

to action-0-driver
	;; if position is equal of customer: ask costumer to get in and change state
	ifelse xcor = [xcor] of customer and ycor = [ycor] of customer [
		ask customer [
			get-in
		]
		going-to-destination-change
	][
		;; else move to customer
		go-towards self customer
	]
end

to action-1-driver
	ifelse xcor = [xcor] of [destination] of customer and ycor = [ycor] of [destination] of customer [
		ask customer [
			get-out
		]
		change-to-free
	][
		; else move to customer
		go-towards self [destination] of customer
	]
end

to change-to-free
	set_state_driver 2
	set shape "circle 2"
	set customer nobody
end

to going-to-customer-change
	set_state_driver 0
	set shape "circle"
end

to going-to-destination-change
	set_state_driver 1
	set shape "target"
end

; ---------- this function takes care of executing the correct assignment function for drivers ------------
to assignment_policy_fn_drivers [current_person]
	if not empty? sort drivers with [state = 2] [

		let type_of_driver? "taxi"
		let radius_driver_policy radius_driver_policy_taxi
		if uber? current_person [
			set type_of_driver? "uber"
			set radius_driver_policy radius_driver_policy_uber
		]

		; decide which policy to use for choosing the driver
		let drivers_set drivers with [distance current_person <= radius_driver_policy / 100 * (max list max-x max-y) AND state = 2 AND type-of-driver = type_of_driver?]

		let driverToBeAssigned nobody

		ifelse type_of_driver? = "uber" [

			ifelse choosing_driver_policy_code_uber = "closest" [
				set driverToBeAssigned min-one-of drivers_set [distance current_person]
			][
				ifelse choosing_driver_policy_code_uber = "fifo" [
					set driverToBeAssigned min-one-of drivers_set [last_status_change]
				][
					if choosing_driver_policy_code_uber = "randomly" [
						set driverToBeAssigned one-of drivers_set	
					]
				]
			]
			
		][

			if type_of_driver? = "taxi" [
				ifelse choosing_driver_policy_code_taxi = "closest" [
					set driverToBeAssigned min-one-of drivers_set [distance current_person]
				][
					ifelse choosing_driver_policy_code_taxi = "fifo" [
						set driverToBeAssigned min-one-of drivers_set [last_status_change]
					][
						if choosing_driver_policy_code_taxi = "randomly" [
							set driverToBeAssigned one-of drivers_set	
						]
					]
				]
			]

		]

		if driverToBeAssigned != nobody [
			set own-driver driverToBeAssigned ; perhaps use ask current_person [set own-dri...
			ask own-driver [
				going-to-customer-change
				ask current_person [
					set_state_person 2
				]
				set customer current_person 
			]
		]
	]
end

to set_state_driver [value]
	set state value
	set last_status_change ticks
end
