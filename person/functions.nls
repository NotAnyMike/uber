; FILE FOR PERSON'S FUNCTIONS

to person-act 
	if state = 0 [
		if random 100 < 1 [
			let current_position current_vertice
			; Changing his status
			set_state_person 1

			; Selecting a different vertice
			set destination one-of vertices with [self != current_position]
		]
	]
end

to get-in
	set_state_person 2
	hide-turtle
end

to get-out
	set_state_person 0
	set current_vertice destination
	move-to destination
	show-turtle
end

;----------- decision rule -------------
to-report uber? [current_person]
	let uber 0
	let taxi 0

	; calculating the heutistic for history ---------------
	let uber-hist 0
	let taxi-hist 0
	let i 0
	let n length [history_uber] of current_person
	repeat n [
	;foreach [history_uber] of current_person [
		set uber-hist uber-hist + item i [history_uber] of current_person / ( i + 1 )
		set taxi-hist taxi-hist + item i [history_taxi] of current_person / ( i + 1 )
		set i i + 1
		if perfect_memory [set i 0]
	]

	; regularizing results
	ifelse taxi-hist > uber-hist [
		; in order to avoid dividing by zero
		ifelse taxi-hist = 0 [
			set uber-hist 0
		][
			set uber-hist 1 - (uber-hist / taxi-hist)
		]
		set taxi-hist 0
	][
		; in order to avoid dividing by zero
		ifelse uber-hist = 0 [
			set taxi-hist 0
		][
			set taxi-hist 1 - (taxi-hist / uber-hist)
		]
		set uber-hist 0
	]
	; -----------------------------------------------------


	; calculating heuristic familiarity -------------------
	; -----------------------------------------------------

	; calculating price heuristic -------------------------
	; -----------------------------------------------------

	; adding all together ---------------------------------
	set uber uber-hist
	set taxi taxi-hist
	; -----------------------------------------------------

	ifelse uber > taxi [
		report true
	][
		ifelse uber = taxi [
			; if tie chose randomly
			report one-of [true false]
		][
			report false
		]
	]
end

;----------- set_state_persons ---------
to set_state_person [value]
	if state = 1 AND value = 2 [
		if is-driver? own-driver [
			ifelse [type-of-driver] of own-driver = "taxi" [
				set history_taxi fput (ticks - last_status_change) history_taxi
				set history_uber fput 0 history_uber
			][
				if [type-of-driver] of own-driver = "uber" [
					set history_uber fput (ticks - last_status_change) history_uber
					set history_taxi fput 0 history_taxi
				]
			]
		]
	]
	;set last_status_change date-and-time
	set state value
	set last_status_change ticks
end 
;-----------------------------
	
; ---------- this fn takes care of running the right assignment policy ------------
to assignment_policy_fn_persons
	ifelse choosing_customer_policy_code = "randomly" [
		randomly_policy_persons
	][
		if choosing_customer_policy_code = "fifo" [
			fifo_policy_persons
		]
	]
end

; ---------- randomly assignement policy for persons ----------
to randomly_policy_persons
	ask people with [state = 1] [
		let current_person self
		assignment_policy_fn_drivers current_person
	]
end

; ---------- fifo assignement policy for persons --------------
to fifo_policy_persons
	if not empty? sort people with [state = 1][
		foreach sort-on [last_status_change] people with [state = 1][
			[x] -> ask x [
				assignment_policy_fn_drivers x
			]
		]
	]
end
